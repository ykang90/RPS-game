// -----------------------------------------------------------------------------
// CARVES Interface Generation – Modular Pipeline (Editor‑only)  (v2)
// -----------------------------------------------------------------------------
// ◇ 移除硬编码路径：所有输出路径来源于 CarvesSettings.asset
//   - settings.GeneratedInterfaceDir   (string)  如 "Generated/Interfaces"
//   - settings.LinkXmlPath            (string)  如 "Carves_AutoLink.xml" (相对工程根)
//   - settings.MetaInfoName           (string)  默认 "CarvesMetaInfo.asset"
//   如果 Settings 不存在会在 Assets/CARVES/ 目录下自动创建并写入默认值。
// -----------------------------------------------------------------------------
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using CARVES.Abstracts;
using CARVES.Core;
using UnityEditor;
using UnityEngine;
using Assembly = System.Reflection.Assembly;

namespace CARVES.Editor
{
    internal static class SettingsUtil
    {
        public const string AssetsDir = "Assets";

        public static CarvesSettings LoadOrCreate()
        {
            var guid = AssetDatabase.FindAssets("t:CarvesSettings").FirstOrDefault();
            if (!string.IsNullOrEmpty(guid))
                return AssetDatabase.LoadAssetAtPath<CarvesSettings>(AssetDatabase.GUIDToAssetPath(guid));

            Directory.CreateDirectory(CarvesSettings.DefaultDir);
            var asset = ScriptableObject.CreateInstance<CarvesSettings>();
            AssetDatabase.CreateAsset(asset, Path.Combine(CarvesSettings.DefaultDir, "CarvesSettings.asset"));
            AssetDatabase.SaveAssets();
            Debug.Log("CARVES ▶ Auto‑created CarvesSettings at " + CarvesSettings.DefaultDir);
            return asset;
        }

        public static string GenOutAbs(CarvesSettings s) => Path.Combine(AssetsDir, s.RootPath, s.GeneratedInterfaceDir);
        public static string LinkXmlAbs(CarvesSettings s) => Path.Combine(Application.dataPath, "..", s.LinkXmlPath);
        public static string MetaAbs(CarvesSettings s)
        {
            var dir = Path.GetDirectoryName(AssetDatabase.GetAssetPath(s))!;
            return Path.Combine(dir,  s.MetaInfoName).Replace('\\','/');
        }
        public static void SyncScanAssembliesFromAsmDefs(CarvesSettings settings)
        {
            var guids = AssetDatabase.FindAssets("t:AssemblyDefinitionAsset", new[]{ "Assets" });
            var names = guids.Select(g =>
                {
                    var json = File.ReadAllText(AssetDatabase.GUIDToAssetPath(g));
                    var marker = "\"name\":";
                    var idx = json.IndexOf(marker);
                    if (idx < 0) return null;
                    var start = json.IndexOf('"', idx + marker.Length) + 1;
                    var end   = json.IndexOf('"', start);
                    return json.Substring(start, end - start);
                })
                .Where(n => !string.IsNullOrEmpty(n))
                .Distinct()
                .ToArray();

            //settings.ScanAssemblies = names;
            EditorUtility.SetDirty(settings);
            AssetDatabase.SaveAssets();
            Debug.Log($"CARVES ▶ 已同步 {names.Length} 个 asmdef 到 ScanAssemblies");
        }
    }

    // ─────────────① 扫描器 ────────────────────────────────────
    internal static class CarvesTypeScanner
    {
        public static IEnumerable<Type> Scan()
        {
            var settings = SettingsUtil.LoadOrCreate();
            // ① 如果用户在 Settings.ScanAssemblies 里填了 asmdef 名称，就只扫描那些程序集
            // ② 否则，退回到默认的 Assembly-CSharp
            var toScan = settings.ScanAssemblies.Any()
                ? new HashSet<string>(settings.ScanAssemblies.Select(s=>s.name))
                : new HashSet<string> { "Assembly-CSharp" };
            return AppDomain.CurrentDomain.GetAssemblies()
                .Where(a => toScan.Contains(a.GetName().Name))
                .SelectMany(SafeGet)
                .Where(t => !t.IsAbstract
                            && t.GetCustomAttribute<CarvesLayerAttribute>() != null);
        }

        static IEnumerable<Type> SafeGet(Assembly a)
        {
            try { return a.GetTypes(); }
            catch { return Array.Empty<Type>(); }
        }
    }

    // ─────────────② 接口生成器 ─────────────────────────────────
    internal static class InterfaceBuilder
    {
        public static string Build(Type cls,out string[] interfaces)
        {
            var ns = CarvesSettings.Ns_GeneratedCarves;
            var asm = $"{CarvesSettings.GeneratedAssemblyName}, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null";
            var sb=new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine($"namespace {CarvesSettings.Ns_GeneratedCarves}");
            //sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            interfaces = new[]
            {
                //$"{ns}.{GenInfo(sb, cls)}, {asm}",
                $"{ns}.{GenApi(sb, cls)}, {asm}"
            };
            sb.AppendLine("}");
            return sb.ToString();
        }
        static string GenInfo(StringBuilder sb ,Type cls)
        {
            var interfaceName = $"I{cls.Name}_Info";
            sb.AppendLine($"    public interface {interfaceName}");
            sb.AppendLine("    {");
            foreach (var p in cls.GetProperties(BindingFlags.Public|BindingFlags.Instance|BindingFlags.DeclaredOnly)
                         .Where(p => p.CanRead && p.GetIndexParameters().Length == 0))
                sb.AppendLine($"        {TypeName(p.PropertyType)} {p.Name} {{ get; }}");

            foreach (var m in cls.GetMethods(BindingFlags.Public|BindingFlags.Instance|BindingFlags.DeclaredOnly)
                         .Where(IsInfo))
                sb.AppendLine("        " + MethodSig(m));
            sb.AppendLine("    }");
            sb.AppendLine();
            return interfaceName;
        }
        static string GenApi(StringBuilder sb,Type cls)
        {
            var interfaceName = $"I{cls.Name}_Api";
            sb.AppendLine($"    public interface {interfaceName} " 
                          //+ $": I{cls.Name}_Info"
                          );
            sb.AppendLine("    {");
            foreach (var m in cls.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
                         .Where(m => IsApi(m) && !m.IsSpecialName && !m.IsConstructor))
                sb.AppendLine("        " + MethodSig(m));
            sb.AppendLine("    }");
            return interfaceName;
        }

        static bool IsInfo(MethodInfo m) =>
            m.GetCustomAttribute<CarvesMethodAttribute>()?.Access == CarvesMethodAccess.Info;

        static bool IsApi(MethodInfo m) =>
            m.GetCustomAttribute<CarvesMethodAttribute>()?.Access == CarvesMethodAccess.Api;
        static string MethodSig(MethodInfo m)
        {
            var ret = m.ReturnType == typeof(void) ? "void" : TypeName(m.ReturnType);
            var gen = m.IsGenericMethodDefinition
                ? "<" + string.Join(", ", m.GetGenericArguments().Select(a => a.Name)) + ">"
                : "";
            var pars = string.Join(", ", m.GetParameters()
                .Select(pa => $"{TypeName(pa.ParameterType)} {pa.Name}"));

            var sb = new StringBuilder();
            sb.Append(ret).Append(' ').Append(m.Name).Append(gen).Append('(').Append(pars).Append(')');

            if (m.IsGenericMethodDefinition)
                foreach (var g in m.GetGenericArguments())
                {
                    var w = WhereClause(g);
                    if (!string.IsNullOrEmpty(w)) sb.Append(" where ").Append(w);
                }
            sb.Append(';');
            return sb.ToString();
        }
        static string WhereClause(Type g)
        {
            var parts = g.GetGenericParameterConstraints().Select(TypeName).ToList();

            var a = g.GenericParameterAttributes;
            if (a.HasFlag(GenericParameterAttributes.ReferenceTypeConstraint)) parts.Add("class");
            else if (a.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint)) parts.Add("struct");
            if (a.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint)) parts.Add("new()");

            return parts.Count == 0 ? "" : $"{g.Name} : {string.Join(", ", parts)}";
        }

        static string TypeName(Type t)
        {
            // ① 处理 ref / out（ByRef）——先取元素类型再拼接 &
            if (t.IsByRef)
                return TypeName(t.GetElementType()!) + "&";   // '&' 仅作可读标识，可改成空格

            // ② 已有的 generic-parameter 分支
            if (t.IsGenericParameter) return t.Name;

            // ③ 已有的泛型分支
            if (t.IsGenericType)
            {
                var def = t.GetGenericTypeDefinition(); // System.Threading.Tasks.Task`1
                var raw = def.FullName!; // 带完整命名空间
                raw = raw.Substring(0, raw.IndexOf('`'));
                var args = string.Join(", ", t.GetGenericArguments().Select(TypeName));
                return $"{raw}<{args}>";
            }

            // ④ 最后才取 FullName，确保非 null
            return t.FullName?.Replace('+', '.') ?? t.Name;
        }
    }

    // ─────────────③ SourceWriter──────────────────────────────
    internal static class SourceWriter
    {
        //public static void WriteInterface(Type cls,string code,string outDir)
        //{
        //    Directory.CreateDirectory(outDir);
        //    File.WriteAllText(Path.Combine(outDir,$"I{cls.Name}.g.cs"),code);
        //}
        public static string WriteInterface(Type cls, string code, string outDir)
        {
            // ① 生成 “…/Root/Foo/Bar/IPlayer.g.cs”
            var nsDir = string.IsNullOrEmpty(cls.Namespace)
                ? outDir
                : Path.Combine(outDir, cls.Namespace.Replace('.', Path.DirectorySeparatorChar));
            Directory.CreateDirectory(nsDir);
            var file = Path.Combine(nsDir, $"I{cls.Name}.g.cs");
            File.WriteAllText(file, code);
            // 3. 立即导入这个新文件，避免全局 Refresh
            var rel = ToRel(file);
            AssetDatabase.ImportAsset(rel, ImportAssetOptions.ForceUpdate);
            return rel;
        }
        static string ToRel(string abs) => abs.Replace(Application.dataPath, "").Replace('\\','/');
        public static void EnsureImplementsApi(Type cls)
        {
            var path = CarvesUtilities.GetScriptPath(cls);
            if (string.IsNullOrEmpty(path)) return;

            var src = File.ReadAllText(path);
            // 与 InterfaceBuilder 保持一致
            var ifaceName   = $"I{cls.Name}_Api"; // 接口名
            var iface   = $"{CarvesSettings.Ns_GeneratedCarves}.{ifaceName}";         // ← 完全限定名
            if (src.Contains(ifaceName)) return; // 已实现

            // 找到 “class Xxx ... {” 之间的继承链
            var declIdx = src.IndexOf("class " + cls.Name);
            var brace   = src.IndexOf('{', declIdx);
            var colon   = src.IndexOf(':', declIdx, brace - declIdx);

            if (colon < 0)
            {
                // 没有基类/接口——直接添加新的继承链
                src = src.Insert(brace, $" : {iface}\r\n");
            }
            else
            {
                // 已有基类或接口——在 '{' 前插入(同时让'{'推往下一行+4空格), Ixxx_Api需要trim(包括\n)到末尾并加上一个空格
                var inherit = src.Substring(colon + 1, brace - colon - 1).Trim();
                src = src.Insert(brace, string.IsNullOrWhiteSpace(inherit) ? $" : {iface}\r\n    " : $", {iface}\r\n    ");
                //src = src.Insert(brace, $", {iface}");
            }

            File.WriteAllText(path, src);
            AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
        }
    }

    // ─────────────④ MetaRepository────────────────────────────
    internal static class MetaRepository
    {
        public static CarvesMetaInfo Load(string absPath)
        {
            var rel=ToRel(absPath);
            var meta=AssetDatabase.LoadAssetAtPath<CarvesMetaInfo>(rel);
            if(!meta)
            {
                meta=ScriptableObject.CreateInstance<CarvesMetaInfo>();
                meta.Entries=Array.Empty<CarvesMetaEntry>();
                Directory.CreateDirectory(Path.GetDirectoryName(rel)!);
                AssetDatabase.CreateAsset(meta,rel);
            }
            return meta;
        }
        public static void Save(CarvesMetaInfo meta,CarvesMetaEntry[] arr)
        {
            meta.Entries=arr;
            EditorUtility.SetDirty(meta);
            AssetDatabase.SaveAssets();
        }

        public static bool NeedRegen(Type t, CarvesMetaInfo meta)
        {
            var e = meta.Entries.FirstOrDefault(x => x.TypeName == t.Name);
            if (e == null) return true;
            var mtime = File.GetLastWriteTimeUtc(CarvesUtilities.GetScriptPath(t)).Ticks;
            return mtime > e.LastModified;
        }

        static string ToRel(string abs)
        {
            if (abs.Replace('\\', '/').StartsWith(SettingsUtil.AssetsDir))
                return abs.Replace('\\', '/');            // 已是相对路径
            return abs.Replace(Application.dataPath, "").Replace('\\', '/');
        }
    }

    // ─────────────⑤ LinkXmlWriter─────────────────────────────
    internal static class LinkXmlWriter
    {
        public static void Write(IEnumerable<Type> list,string absPath)
        {
            var sb=new StringBuilder();
            sb.AppendLine("<linker>\n  <assembly fullname=\"Assembly-CSharp\">\n");
            foreach(var t in list)
                sb.AppendLine($"    <type fullname=\"{t.FullName}\" preserve=\"all\" />");
            sb.AppendLine("  </assembly>\n</linker>");
            File.WriteAllText(absPath,sb.ToString());
        }
    }

    //──────────────⑥ Orchestrator – 主入口 (等待编译完成)─────────
    [InitializeOnLoad]
    internal static class CarvesInterfaceOrchestrator
    {
        static CarvesInterfaceOrchestrator()=>EditorApplication.delayCall+=CallRun;

        static void CallRun()
        {
            var settings=SettingsUtil.LoadOrCreate();
            if(!settings.AutoGenerate) return;
            WaitCompileAndRun();
        }

        /*──────── MENU ────────*/
        [MenuItem("CARVES/Generate", priority = 100)]
        static void Generate()
        {
            ApplyCompilePreference();
            AssetDatabase.Refresh();          // 若脚本有改动会进入编译 → 域重载
            Run();
        }

        // 原有切换方法
        [MenuItem("CARVES/Toggle Auto Compilation", priority = 110)]
        static void MenuToggle()
        {
            var s = SettingsUtil.LoadOrCreate();
            if (!s) { Debug.LogWarning("CARVES ▶ Settings asset missing"); return; }
            s.AutoGenerate = !s.AutoGenerate;
            EditorUtility.SetDirty(s);
            AssetDatabase.SaveAssets();
            ApplyCompilePreference();
            Debug.Log($"CARVES ▶ Auto-compile {(s.AutoGenerate ? "ON" : "OFF")}");
        }

        // 新增验证方法，用于更新勾选状态
        [MenuItem("CARVES/Toggle Auto Compilation", validate = true)]
        static bool MenuToggleValidate()
        {
            var s = SettingsUtil.LoadOrCreate();
            // 让菜单项显示勾选
            Menu.SetChecked("CARVES/Toggle Auto Compilation", s.AutoGenerate);
            return true; // 始终启用该菜单项
        }


        static void ApplyCompilePreference()
        {
            var s = SettingsUtil.LoadOrCreate();
            if (!s) return;
            const string k = "kAutoRefresh";
            EditorPrefs.SetBool(k, s.AutoGenerate);
            if (s.AutoGenerate) EditorApplication.UnlockReloadAssemblies();
            else EditorApplication.LockReloadAssemblies();
        }

        static void WaitCompileAndRun()
        {
            if(EditorApplication.isCompiling)
            {
                // 继续排队，直到编译完成
                EditorApplication.delayCall+=WaitCompileAndRun;
                return;
            }
            Run();
        }

        static void Run()
        {
            var settings=SettingsUtil.LoadOrCreate();
            var metaAbs=SettingsUtil.MetaAbs(settings);
            var genOut =SettingsUtil.GenOutAbs(settings);
            var linkAbs=SettingsUtil.LinkXmlAbs(settings);

            var meta=MetaRepository.Load(metaAbs);
            var updated=new List<CarvesMetaEntry>();
            var needLink=new List<Type>();

            foreach(var t in CarvesTypeScanner.Scan())
            {
                var attr=t.GetCustomAttribute<CarvesLayerAttribute>();
                if (attr.Layer == CarvesLayers.Shared)
                {
                }
                var regen = MetaRepository.NeedRegen(t, meta);
                string fileRel = string.Empty;
                string[] interfaceNames = Array.Empty<string>();
                // ① 是否真的写文件
                var writeInterface = settings.GenerateInterfaceFiles
                                     && attr.GenerateInterface == GenerateInterfaceType.ReadWrite;
                if (writeInterface)
                {
                    if (regen) fileRel = SourceWriter.WriteInterface(t, 
                        InterfaceBuilder.Build(t, out interfaceNames), genOut);
                    else
                    {
                        var entry = meta.Entries.First(e => e.TypeName == t.Name);
                        fileRel = entry.InterfacePath;
                        interfaceNames = entry.InterfaceNames;
                    }
                    if (regen) SourceWriter.EnsureImplementsApi(t);
                }
                updated.Add(new CarvesMetaEntry
                {
                    TypeName = t.Name,
                    AssemblyQualifiedName = t.AssemblyQualifiedName,
                    InterfacePath = fileRel,
                    Layer = attr.Layer,
                    InterfaceType = attr.GenerateInterface,
                    RelativePath = GetScriptPath(t),
                    LastModified = File.GetLastWriteTimeUtc(GetScriptPath(t)).Ticks,
                    InterfaceNames = interfaceNames,
                    SelfManage = attr.SelfManage
                });
                needLink.Add(t);
            }
            MetaRepository.Save(meta,updated.ToArray());
            LinkXmlWriter.Write(needLink,linkAbs);
            // ───────── 4) 清理遗留文件/Meta ─────────
            var delCount = OrphanCleaner.RemoveOrphans(genOut, meta);
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
            if (delCount > 0) Debug.Log($"CARVES ▶ 清理冗余接口文件 {delCount} 个");
            Debug.Log("CARVES ▶ Interface pipeline finished");
        }

        static string GetScriptPath(Type cls)
        {
            foreach (var g in AssetDatabase.FindAssets($"{cls.Name} t:Script"))
            {
                var p = AssetDatabase.GUIDToAssetPath(g);
                var ms = AssetDatabase.LoadAssetAtPath<MonoScript>(p);
                if (ms && ms.GetClass() == cls) return p;
            }
            return string.Empty;
        }

    }

    internal static class OrphanCleaner
    {
        /// <summary>删除生成目录中未出现在 meta 的 *.g.cs 文件</summary>
        public static int RemoveOrphans(string genOutAbs, CarvesMetaInfo meta)
        {
            var whitelist = new HashSet<string>(meta.Entries.Select(e=>e.InterfacePath));
            var removed = 0;
            //先检查目录的存在
            if (!Directory.Exists(genOutAbs))
            {
                Debug.LogWarning($"CARVES ▶ 生成目录 {genOutAbs} 不存在，无法清理冗余文件");
                return removed;
            }

            foreach (var file in Directory.GetFiles(genOutAbs, "*.g.cs", SearchOption.AllDirectories))
            {
                var rel = file.Replace(Application.dataPath, "").Replace('\\', '/');
                if (whitelist.Contains(rel)) continue;
                AssetDatabase.DeleteAsset(rel);
                removed++;
            }
            CleanEmptyDirs(genOutAbs);
            return removed;
        }

        static void CleanEmptyDirs(string dir)
        {
            foreach (var sub in Directory.GetDirectories(dir))
                CleanEmptyDirs(sub);

            if (Directory.EnumerateFileSystemEntries(dir).Any()) return;
            AssetDatabase.DeleteAsset(dir.Replace(Application.dataPath, "").Replace('\\', '/'));
        }
    }

    // ─────────────⑦ Utilities─────────────────────────────────
    internal static class CarvesUtilities
    {
        public static string GetScriptPath(Type cls)
        {
            foreach(var g in AssetDatabase.FindAssets(cls.Name+" t:Script"))
            {
                var p=AssetDatabase.GUIDToAssetPath(g);
                if(AssetDatabase.LoadAssetAtPath<MonoScript>(p).GetClass()==cls) return p;
            }
            return string.Empty;
        }
    }
}
#endif